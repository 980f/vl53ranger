<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>errorManagement</title>
    <meta name="author" content="Andy Heilveil (github/980f)">
  </head>
  <body>
    <p>VL53L0X</p>
    <p>Error management</p>
    <br>
    The defined errors:<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td>ERROR_NONE</td>
          <td>0</td>
          <td>not an error</td>
          <td>resolution</td>
        </tr>
        <tr>
          <td>ERROR_CALIBRATION_WARNING</td>
          <td><br>
          </td>
          <td>no instances</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_MIN_CLIPPED</td>
          <td>parameter</td>
          <td>no instances</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_UNDEFINED</td>
          <td><br>
          </td>
          <td>none</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_INVALID_PARAMS</td>
          <td>parameter<br>
            (human error)</td>
          <td>many argument checks</td>
          <td>compile time errors via rigorous type checking. Someone has to cast around the types and gets what they deserve if we throw.<br>
            A boolean for each instance, clearable <em>en masse</em> allows for easy postmortem analysis.<br>
            Set bit and return 'failed'.</td>
        </tr>
        <tr>
          <td>ERROR_NOT_SUPPORTED</td>
          <td>&nbsp;</td>
          <td>adafruit version check</td>
          <td>feature not needed, should be warning at best</td>
        </tr>
        <tr>
          <td>ERROR_RANGE_ERROR</td>
          <td>hw</td>
          <td>*cal total_count 0 at end of 50 or any error during iteration<br>
            GetInterruptMaskStatus either of two undocumented bits set</td>
          <td>ones from calibration are now in background processes<br>
            <br>
            GIMS ones: seems to mean that the bits being waiting on will never be set so the loop needs to break. <br>
            <br>
            A sentinel value can take care of this, or simply let the bits persist back to the user where they should test them all, not just the one of interest.</td>
        </tr>
        <tr>
          <td>ERROR_TIME_OUT</td>
          <td>hw </td>
          <td>
            <ul>
              <li>adafruit::stopRangeContinuous</li>
              <li>slowpoll measurement_poll_for_completion </li>
              <li>fastpoll StartMeasurement(single)</li>
              <li>fastpoll device_read_strobe packed90 reads</li>
            </ul>
          </td>
          <td>need more realistic timeouts to see if can be done blocking without penalty<br>
            else waiting is moved to state machines and they can notify on state transition failure.</td>
        </tr>
        <tr>
          <td>ERROR_MODE_NOT_SUPPORTED</td>
          <td>&nbsp;parameter</td>
          <td> SetPowerMode half the enums are invalid<br>
            SetDeviceMode only 5 valid enums<br>
            StartMeasurement only 3 valid enums </td>
          <td>better type definitions should catch these at compile time.<br>
            only internal/expert code might want to type cast when splitting a hardware value into fields.</td>
        </tr>
        <tr>
          <td>ERROR_BUFFER_TOO_SMALL</td>
          <td>&nbsp;</td>
          <td>no instances</td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_GPIO_NOT_EXISTING</td>
          <td>&nbsp;parameter</td>
          <td>SetGpioConfig<br>
            GetGpioConfig<br>
          </td>
          <td>make a gpio object and hide possibility of user entering an invalid value.</td>
        </tr>
        <tr>
          <td>ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED</td>
          <td>&nbsp;</td>
          <td>SetGpioConfig parameter<br>
            GetGpioConfig bad value in hardware </td>
          <td>see 'not existing'</td>
        </tr>
        <tr>
          <td>ERROR_INTERRUPT_NOT_CLEARED</td>
          <td>&nbsp;hw</td>
          <td>ClearInterruptMask<br>
          </td>
          <td>THROW <br>
            reinit needed</td>
        </tr>
        <tr>
          <td><br>
          </td>
          <td><br>
          </td>
          <td><br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_CONTROL_INTERFACE</td>
          <td>20<br>
            most likely parameter error as in wrong size for a register read. </td>
          <td>Actual or suspected I2C error<br>
            Read: fewer bytes received <br>
            Write: buffer overflow<br>
            theoretically:<br>
            <div id="wikitext">
              <meta http-equiv="content-type" content="text/html; charset=utf-8">
              <ul>
                <li>0:success </li>
                <li>1:data too long to fit in transmit buffer </li>
                <li>2:received NACK on transmit of address </li>
                <li>3:received NACK on transmit of data </li>
                <li>4:other error </li>
              </ul>
            </div>
            <br>
          </td>
          <td>log detail THROW <br>
            reinit needed</td>
        </tr>
        <tr>
          <td>ERROR_INVALID_COMMAND</td>
          <td>30</td>
          <td>none<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_DIVISION_BY_ZERO</td>
          <td>40</td>
          <td>none<br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>ERROR_REF_SPAD_INIT</td>
          <td>50<br>
          </td>
          <td>perform_ref_spad_management<br>
            enable_ref_spads<br>
            -all are variants of bits not being found.<br>
          </td>
          <td>these are process responses, <br>
            record greater detail in a status variable and return 'failed'.</td>
        </tr>
        <tr>
          <td>ERROR_NOT_IMPLEMENTED</td>
          <td>99<br>
            human error</td>
          <td>at function entry<br>
          </td>
          <td>THROW<br>
            source code is bad. This is not totally unreasonable if the source dynamically adjust for different sensors attached in which case it has to know to not attempt such operations and has failed seriously if it has.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <br>
    <br>
    <hr><br>
    The majority of instances of testing for errors is after I2C comm.<br>
    <br>
    The device disappearing can be detected and recorded.<br>
    The device can be probed via 0 byte writes when it has not been found present.<br>
    Xmit overflow is a developer error and no local recovery is reasonable.<br>
    Recv under flow is a developer error or hideous noise.<br>
    <br>
    <br>
    separate counters for each I2C error code would be cute.<br>
    <br>
    <hr><br>
    <br>
    Since we are not going to enable exceptions but rather do a longjmp we need to:<br>
    <ol>
      <li>verify that no new's or mallocs of any kind occur.</li>
      <ol>
        <li>since the code was received as C not C++we should not have added new's and we can grep for ?alloc: none present.</li>
      </ol>
      <li>that all RAII 'pop' operations are unnecessary if we throw.</li>
      <ol>
        <li>all popper class derivatives are I2C and any throws are hopeless errors.</li>
        <li>all ~'s inspected and no others are destructors</li>
      </ol>
    </ol>
    As such we can only THROW for communications errors or errors for which complete reinit of the device is the remedy.<br>
    All comm errors are hopeless. They are either hw error in realtime or permanent software errors.<br>
    It would be nice to record the I2C operation attempted. Just knowing the address and length would do most of what is needed.<br>
    So: record lastIndex, lastLength and then longjmp(commerror).<br>
    <br>
    <hr><br>
    For a blocking implementation every entry point into the api needs a setjmp and error handler.<br>
    <br>
    For a non-blocking implementation the state machine has a setjmp at critical places.<br>
    <br>
    RAII allows us to make a stack via copying the current jmp_buf values locally, then call setjmp and on method return copy those back.<br>
    <br>
    <br>
    <hr>Procedures<br>
    <br>
    <br>
    SRM&nbsp; (user calls for oneshot mode)<br>
    &nbsp;&nbsp; psm like but not identical to vhphasecal core<br>
    Rate<br>
    &nbsp;&nbsp;&nbsp; SRM<br>
    spad management<br>
    &nbsp;&nbsp;&nbsp; rate X 3<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SRM<br>
    offset cal<br>
    &nbsp;&nbsp;&nbsp; 50 X SRM<br>
    xtalk:<br>
    &nbsp;&nbsp;&nbsp; 50 X SRM<br>
    <br>
    vhvphasecal<br>
    &nbsp;&nbsp;&nbsp; start/MPC/CLI private copy<br>
    <br>
    <br>
    <br>
    waiting on completion calls:<br>
    &nbsp;&nbsp;&nbsp; vhvphasecal process (no values precollected)<br>
    &nbsp;&nbsp; srm for rate (rate value precollected)<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; user<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; srm for rate in spad<br>
    &nbsp;&nbsp; srm for user single shot, but callback works for continuous as well if interrupt not used.<br>
    &nbsp;&nbsp; srm for offset cal<br>
    &nbsp;&nbsp; srm for xtalk cal<br>
    <br>
    starting<br>
    &nbsp;&nbsp;&nbsp; if already continuous goose<br>
    &nbsp;&nbsp;&nbsp; else start<br>
    &nbsp;&nbsp; on started poll completion<br>
    <br>
    clearinterruptmask&nbsp; (10 bytes up to 3 times, byte= 10 bits at 400kHz 25us each=&gt; 250us to 750us, not quite a milli.)<br>
    <br>
    stopping continuous<br>
    <br>
    <hr><br>
    <br>
    loading tuning table : (used by checkandloadinterrupt(1))<br>
    &nbsp;&nbsp;&nbsp; max per call? 75&nbsp; us per triplet, maybe 5 per call. 81/5 = 17 ms instead of 6 ms.12 per call, 7 ms, 30 per call has to be dynamic app choice.<br>
    &nbsp;&nbsp;&nbsp; pointer for state, init to start of table<br>
    &nbsp;&nbsp;&nbsp; higher priority than loopers.<br>
    <br>
    <br>
    --<br>
    SRM: single ranging measurement:<br>
    set device mode to single<br>
    perform single measurement<br>
    getranging data<br>
    clearinteruptmask(0)<br>
    <br>
    <br>
    --<br>
    Rate: ref signal measurement:&nbsp; (used by spad stuff a few times)<br>
    save sequenceConfig shadow<br>
    set SC to 0xC0<br>
    single ranging measurement<br>
    ffread peak singal rate<br>
    restore sequenceConfig<br>
    <br>
    --<br>
    xtalk calibration (distance):<br>
    disable xtalkcomp<br>
    disable range ingore<br>
    <br>
    do 50 single ranging measurement (trusts seqconfig)<br>
    do math and set and enable xtalkcompensation<br>
    --<br>
    <br>
    offset calibration:<br>
    set offset=0<br>
    record and clear TCC enable<br>
    disable range ignore<br>
    do 50 single ranging measurements<br>
    <br>
    do math<br>
    set and record offsetcaldata<br>
    restore TCC (if was set).<br>
    --<br>
    ref calibration<br>
    &nbsp; vhv and phase cal<br>
    &nbsp; 2 X single_ref_calibration<br>
    --<br>
    single_ref_calibratoin<br>
    &nbsp;start=mode_start_stop | vhv of phase cal choice<br>
    MPC<br>
    clearinterruptmask 0<br>
    start=0;<br>
    --<br>
    ref spad management:<br>
    lots of settings<br>
    perf ref signal measurement<br>
    &nbsp;&nbsp;&nbsp; maybe change spad type<br>
    &nbsp;&nbsp;&nbsp; ref signal measuement<br>
    thnk some more and <br>
    maybe ref signal measurement<br>
    <br>
    <br>
    --<br>
    perform single measurement:<br>
    if device mode is single startmeasurement<br>
    measurementpollforcompletion &lt;=-is ready, failed, broke.<br>
    if is in single mode set palstate to idle. (else it is unchanged)<br>
    <br>
    --<br>
    startmeasurement:<br>
    record device mode<br>
    record stop code<br>
    if single<br>
    &nbsp;&nbsp;&nbsp; start=1<br>
    &nbsp;&nbsp; wait until it reads back that bit as a zero<br>
    if continuous<br>
    &nbsp; checkandloadinterrupt 1&nbsp; 6ms!<br>
    &nbsp; start=backtoback<br>
    &nbsp; palstate=running<br>
    if continuous timed<br>
    &nbsp; checkandloadinterrupt 1<br>
    &nbsp; start=modetimed<br>
    &nbsp; palstate=running<br>
    <br>
    --<br>
    checkandloadinterrupt<br>
    &nbsp;if cached function&nbsp; is threshold sensing <br>
    &nbsp;&nbsp; if threshs both &gt;255<br>
    &nbsp;&nbsp; if starting load tuning settings <br>
    &nbsp;&nbsp; else 4X3 = 12 =&gt;300us<br>
    &nbsp;&nbsp; <br>
    --<br>
    clear interrupt mask (ignored)<br>
    try three times-<br>
    &nbsp;&nbsp;&nbsp; send 1<br>
    &nbsp;&nbsp;&nbsp; send 0<br>
    &nbsp;&nbsp;&nbsp; read<br>
    &nbsp;&nbsp;&nbsp; done of bits&lt;2,0&gt; are all zero.<br>
    return success
  </body>
</html>
